mod help_menu_format;
mod key;
mod operations;

use anyhow::{bail, Context, Error, Result};
use derive_more::From;
use serde::Deserialize;
use std::sync::Arc;
use std::{collections::HashMap, fmt, str};
use tokio::sync::Mutex;

use super::table::Table;
use crate::ui::EnvVariables;

pub use self::help_menu_format::{KeybindingsHelpMenuColumn, KeybindingsHelpMenuFormat};
pub use self::key::{KeyCode, KeyEvent, KeyModifier};
pub use self::operations::{OperationExecutable, OperationParsed, Operations, OperationsParsed};

pub struct Keybindings(HashMap<KeyEvent, Operations>);

impl Keybindings {
    pub fn get_operations(&self, key: &KeyEvent) -> Option<&Operations> {
        self.0.get(key)
    }

    pub fn from_parsed(
        keybindings_parsed: KeybindingsParsed,
        env_variables: &Arc<Mutex<EnvVariables>>,
    ) -> Self {
        Self(
            keybindings_parsed
                .0
                .into_iter()
                .map(|(key, (ops, _desc))| (key, Operations::from_parsed(ops, env_variables)))
                .collect(),
        )
    }
}

#[derive(Debug, Clone, PartialEq, Eq, From)]
pub struct KeybindingsParsed(HashMap<KeyEvent, (OperationsParsed, Description)>);

// TODO: should be generated by some crate

/// Allow initialization without `Description`.
impl From<HashMap<KeyEvent, OperationsParsed>> for KeybindingsParsed {
    fn from(value: HashMap<KeyEvent, OperationsParsed>) -> Self {
        Self(
            value
                .into_iter()
                .map(|(key, ops)| (key, (ops, Description::default())))
                .collect(),
        )
    }
}

impl KeybindingsParsed {
    /// Merge two keybinding hashmaps, where a value is taken from `opt_a` over
    /// `opt_b` on identical keys.
    pub fn merge(opt_a: Option<Self>, opt_b: Option<Self>) -> Option<Self> {
        match opt_a {
            Some(a) => match opt_b {
                Some(b) => {
                    // If `a` and `b` have same key => keep `a`'s value
                    let mut merged = b.0;
                    merged.extend(a.0);
                    Some(Self(merged))
                }
                None => Some(a),
            },
            None => opt_b,
        }
    }
}

type KeyPrintable = String;
type OperationsPrintable = String;
type DescriptionPrintable = String;

#[derive(Debug, Clone, From)]
pub struct KeybindingsPrintable {
    keybindings: HashMap<KeyPrintable, (OperationsPrintable, DescriptionPrintable)>,
    format: KeybindingsHelpMenuFormat,
    header_column_names: Vec<String>,
}

impl KeybindingsPrintable {
    pub fn new(keybindings_parsed: KeybindingsParsed, format: KeybindingsHelpMenuFormat) -> Self {
        let keybindings_printable = keybindings_parsed
            .0
            .into_iter()
            .map(|(key, (operations, description))| {
                (
                    key.to_string(),
                    (operations.to_string(), description.to_string()),
                )
            })
            .collect();

        let header_column_names = (&format)
            .into_iter()
            .map(|column_name| column_name.to_string())
            .collect();

        Self {
            keybindings: keybindings_printable,
            format,
            header_column_names,
        }
    }

    pub fn display<U>(&self, display_width: U) -> String
    where
        usize: From<U>,
    {
        let column_names = self.header_column_names.as_slice();

        let rows_iter = self
            .keybindings
            .iter()
            .map(|(key, (operations, description))| {
                // TODO: optimize, since currently O(n^2) (iterating format for every keybinding)
                (&self.format).into_iter().map(move |column| match column {
                    KeybindingsHelpMenuColumn::Key => key,
                    KeybindingsHelpMenuColumn::Operations => operations,
                    KeybindingsHelpMenuColumn::Description => description,
                })
            });

        Table::new(rows_iter)
            .width(Some(display_width))
            .left_margin(2)
            .header(column_names)
            .border()
            .make_string()
    }
}

/// Keybindings parsed from TOML.
#[derive(Debug, Deserialize, Clone)]
#[cfg_attr(test, derive(PartialEq))]
pub struct KeybindingsToml(HashMap<KeyToml, TomlOperationsWithDescription>);

impl TryFrom<KeybindingsToml> for KeybindingsParsed {
    type Error = anyhow::Error;
    fn try_from(value: KeybindingsToml) -> Result<Self, Self::Error> {
        let keybindings = value
            .0
            .into_iter()
            .map(|(key, operations)| {
                let (operations, description) = match operations {
                    TomlOperationsWithDescription::OpsOnly(operations) => {
                        (operations, Description::default())
                    }
                    TomlOperationsWithDescription::OpsWithDesc {
                        operations,
                        description,
                    } => (operations, Description(description)),
                };
                Ok((
                    key.0
                        .parse()
                        .with_context(|| format!("Invalid key event: {}", key.0))?,
                    (Vec::<String>::from(operations).try_into()?, description),
                ))
            })
            .collect::<Result<_>>()?;
        Ok(Self(keybindings))
    }
}

#[derive(Debug, Deserialize, Clone, PartialEq, Eq, Hash)]
struct KeyToml(String);

#[derive(Debug, Deserialize, Clone)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(untagged)]
pub enum TomlOperationsWithDescription {
    OpsOnly(TomlOperations),
    OpsWithDesc {
        operations: TomlOperations,
        description: Option<String>,
    },
}

#[derive(Debug, Deserialize, Clone)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(untagged)]
pub enum TomlOperations {
    Single(String),
    Multiple(Vec<String>),
}

impl From<TomlOperations> for Vec<String> {
    fn from(toml_ops: TomlOperations) -> Self {
        match toml_ops {
            TomlOperations::Single(op) => vec![op],
            TomlOperations::Multiple(ops) => ops,
        }
    }
}

#[derive(Debug, Deserialize, Clone, PartialEq, Eq, Default)]
struct Description(Option<String>);

impl fmt::Display for Description {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(description) = &self.0 {
            write!(f, "{}", description)?;
        }
        Ok(())
    }
}

// TODO: setup tests for KeybindingsCli: test that both `-b a:c,b:d` and `-b a:c -b b:d` work (clap features)
// TODO: remove once clap supports parsing directly into HashMap<String, Vec<String>>

/// Keybindings parsed from a CLI argument.
#[derive(Debug, Clone, From)]
#[cfg_attr(test, derive(PartialEq))]
pub struct KeybindingsCli(Vec<KeybindingCli>);

impl TryFrom<KeybindingsCli> for KeybindingsParsed {
    type Error = anyhow::Error;
    fn try_from(value: KeybindingsCli) -> Result<Self, Self::Error> {
        let keybindings = value
            .0
            .into_iter()
            .map(|KeybindingCli { key, operations }| {
                Ok((
                    key.parse()
                        .with_context(|| format!("Invalid key event: {}", key))?,
                    (
                        operations.try_into()?,
                        // Descriptions are not available in `KeybindingsCli`.
                        Description::default(),
                    ),
                ))
            })
            .collect::<Result<_>>()?;
        Ok(Self(keybindings))
    }
}

/// A keybinding parsed from a string in the format: `KEY:OP[+OP]*`
#[derive(Debug, Clone)]
#[cfg_attr(test, derive(PartialEq))]
pub struct KeybindingCli {
    key: String,
    operations: Vec<String>,
}

// TODO: replace string parsing with nom
impl str::FromStr for KeybindingCli {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let Some((key, operations)) = s.split_once(':') else {
            bail!("Invalid format: expected \"KEY:OP[+OP]*\", found \"{}\"", s);
        };

        Ok(Self {
            key: key.to_string(),
            operations: operations
                .split('+')
                .map(|op| op.trim().to_owned())
                .collect(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use indoc::indoc;

    #[test]
    fn test_merge_keybindings() {
        let k1 = KeyEvent::new(KeyModifier::None, KeyCode::BackTab);
        let k2 = KeyEvent::new(KeyModifier::None, KeyCode::Backspace);
        let k3 = KeyEvent::new(KeyModifier::None, KeyCode::Delete);

        let v1 = OperationsParsed::from(vec![OperationParsed::ExecuteBlocking("v1".to_string())]);
        let v2 = OperationsParsed::from(vec![OperationParsed::ExecuteBlocking("v2".to_string())]);
        let v3 = OperationsParsed::from(vec![OperationParsed::ExecuteBlocking("v3".to_string())]);
        let v4 = OperationsParsed::from(vec![OperationParsed::ExecuteBlocking("v4".to_string())]);

        let a: KeybindingsParsed = HashMap::from([(k1.clone(), v1), (k3.clone(), v4)]).into();
        let b: KeybindingsParsed = HashMap::from([(k1.clone(), v2), (k2.clone(), v3)]).into();

        let merged = KeybindingsParsed::merge(Some(a.clone()), Some(b.clone()))
            .expect("merge should not be empty given both inputs are some");

        // Assert that values from `a` were prioritized over those from `b`.

        // If both `a` and `b` contain `k1`, check that `a`'s value was used.
        assert!(
            a.0.contains_key(&k1) && b.0.contains_key(&k1),
            "both a and b should contain k1"
        );
        assert_ne!(
            a.0.get(&k1),
            b.0.get(&k1),
            "a and b should contain different values for k1"
        );
        assert_eq!(a.0.get(&k1), merged.0.get(&k1), "a's value should be used");

        // If only `b` contains `k2` (and `a` does not), check that `b`'s
        // value was used.
        assert!(
            b.0.contains_key(&k2) && !a.0.contains_key(&k2),
            "only b should contain k2, a should not"
        );
        assert_eq!(b.0.get(&k2), merged.0.get(&k2), "b's value should be used");

        // If only `a` contains `k3` (and `b` does not), check that `a`'s
        // value was used.
        assert!(
            a.0.contains_key(&k3) && !b.0.contains_key(&k3),
            "only a should contain k3, b should not"
        );
        assert_eq!(a.0.get(&k3), merged.0.get(&k3), "a's value should be used");
    }

    /// `OperationsToml` will always be parsed as a value in a table. To
    /// independently test the parsing of `OperationsToml`, we must parse
    /// into an artificial map with a key `foo`.
    #[derive(Debug, Deserialize, Clone)]
    struct OperationsTomlWrapper {
        foo: TomlOperationsWithDescription,
    }

    #[test]
    fn test_parse_toml_operations() {
        let ops_only_single = r#"foo = "op""#;
        assert_eq!(
            TomlOperationsWithDescription::OpsOnly(TomlOperations::Single("op".to_string())),
            toml::from_str::<OperationsTomlWrapper>(ops_only_single)
                .unwrap()
                .foo
        );

        let ops_only_multiple = r#"foo = [ "op 1", "op 2" ]"#;
        assert_eq!(
            TomlOperationsWithDescription::OpsOnly(TomlOperations::Multiple(vec![
                "op 1".to_string(),
                "op 2".to_string()
            ])),
            toml::from_str::<OperationsTomlWrapper>(ops_only_multiple)
                .unwrap()
                .foo
        );

        let ops_without_desc = r#"foo = { operations = [ "op 1", "op 2" ] }"#;
        assert_eq!(
            TomlOperationsWithDescription::OpsWithDesc {
                operations: TomlOperations::Multiple(vec!["op 1".to_string(), "op 2".to_string()]),
                description: None,
            },
            toml::from_str::<OperationsTomlWrapper>(ops_without_desc)
                .unwrap()
                .foo
        );

        let long_with_desc =
            r#"foo = { operations = [ "op 1", "op 2" ], description = "A custom description" }"#;
        assert_eq!(
            TomlOperationsWithDescription::OpsWithDesc {
                operations: TomlOperations::Multiple(vec!["op 1".to_string(), "op 2".to_string()]),
                description: Some("A custom description".to_string())
            },
            toml::from_str::<OperationsTomlWrapper>(long_with_desc)
                .unwrap()
                .foo
        );
    }

    #[test]
    fn test_parse_keybindings_toml() {
        let keybindings = indoc! {r#"
			"a" = [ "op1", "op2" ]
			"b" = "op"
		"#};

        assert_eq!(
            KeybindingsToml(HashMap::from([
                (
                    KeyToml("a".to_string()),
                    TomlOperationsWithDescription::OpsOnly(TomlOperations::Multiple(vec![
                        "op1".to_string(),
                        "op2".to_string()
                    ]))
                ),
                (
                    KeyToml("b".to_string()),
                    TomlOperationsWithDescription::OpsOnly(TomlOperations::Single(
                        "op".to_string()
                    ))
                )
            ])),
            toml::from_str(keybindings).unwrap()
        );
    }

    #[test]
    fn test_parse_keybinding_cli() {
        let keybinding = "a:op multiple words+op2";

        assert_eq!(
            KeybindingCli {
                key: "a".to_string(),
                operations: vec!["op multiple words".to_string(), "op2".to_string()]
            },
            keybinding.parse().unwrap()
        );
    }
}
